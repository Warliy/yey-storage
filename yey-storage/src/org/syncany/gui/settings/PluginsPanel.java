/*
 * Syncany, www.syncany.org
 * Copyright (C) 2011 Philipp C. Heckel <philipp.heckel@gmail.com> 
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.syncany.gui.settings;

import java.awt.Component;
import java.awt.Insets;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Logger;

import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.UIManager;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.TableModelListener;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.table.TableModel;

import org.syncany.config.Config;
import org.syncany.connection.plugins.PluginInfo;
import org.syncany.connection.plugins.Plugins;

/**
 *
 * @author Philipp C. Heckel <philipp.heckel@gmail.com>
 */
public class PluginsPanel extends SettingsPanel {
    private static final Logger logger = Logger.getLogger(PluginsPanel.class.getSimpleName());
    private ResourceBundle resourceBundle;

    public PluginsPanel() {
    	resourceBundle = Config.getInstance().getResourceBundle();
        initComponents();

        initButtons();
        initTable();
    }

    private void initButtons() {
        btnDelete.setEnabled(false);
    }

    private void initTable() {
        // Content Model & Renderer
        tblPlugins.setModel(new PluginsTableModel());
        //tblFolders.getC

        // Columns
        tblPlugins.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);

        TableColumn colActive = tblPlugins.getColumnModel().getColumn(PluginsTableModel.COLUMN_INDEX_ACTIVE);
        colActive.setPreferredWidth(50);
        colActive.setMaxWidth(50);
        colActive.setResizable(false);

        TableColumn colRemote = tblPlugins.getColumnModel().getColumn(PluginsTableModel.COLUMN_INDEX_NAME);
        colRemote.setPreferredWidth(210);

        TableColumn colLocal = tblPlugins.getColumnModel().getColumn(PluginsTableModel.COLUMN_INDEX_VERSION);
        colLocal.setPreferredWidth(120);

        // Other stuff
        tblPlugins.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        tblPlugins.setShowHorizontalLines(false);
        tblPlugins.setShowVerticalLines(false);
        tblPlugins.setBorder(BorderFactory.createEmptyBorder());

        // Listeners
        tblPlugins.getSelectionModel().addListSelectionListener(new ListSelectionListener() {

            @Override
            public void valueChanged(ListSelectionEvent e) {
                btnDelete.setEnabled(e.getFirstIndex() >= 0);
            }
        });
    }

    @Override
    public void load() {
        // Automatically loaded via FolderTableModel! Nice :-D
    }

    @Override
    public void save() {
        // Automatically saved via FolderTableModel! Nice :-D
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        tblPlugins = new javax.swing.JTable();
        btnAdd = new javax.swing.JButton();
        btnDelete = new javax.swing.JButton();

        setBorder(null);

        jScrollPane1.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        jScrollPane1.setName("jScrollPane1"); // NOI18N

        tblPlugins.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        tblPlugins.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null}
            },
            new String [] {
            		resourceBundle.getString("pp_active_index"), 
            		resourceBundle.getString("pp_plugin_index"), 
            		resourceBundle.getString("pp_version_index")
            }
        ) {
            Class[] types = new Class [] {
                java.lang.Boolean.class, java.lang.Object.class, java.lang.Object.class
            };
            boolean[] canEdit = new boolean [] {
                true, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        tblPlugins.setName("tblPlugins"); // NOI18N
        tblPlugins.setRowHeight(24);
        tblPlugins.setShowHorizontalLines(false);
        tblPlugins.setShowVerticalLines(false);
        tblPlugins.getTableHeader().setReorderingAllowed(false);
        jScrollPane1.setViewportView(tblPlugins);

        btnAdd.setText(resourceBundle.getString("pp_add_plugin"));
        btnAdd.setName("btnAdd"); // NOI18N
        btnAdd.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAddActionPerformed(evt);
            }
        });

        btnDelete.setText(resourceBundle.getString("pp_delete_plugin"));
        btnDelete.setName("btnDelete"); // NOI18N
        btnDelete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDeleteActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 491, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(btnDelete, javax.swing.GroupLayout.PREFERRED_SIZE, 125, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnAdd, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 214, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnAdd)
                    .addComponent(btnDelete))
                .addContainerGap(137, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void btnAddActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAddActionPerformed
        JOptionPane.showMessageDialog(this, resourceBundle.getString("pp_not_supported"));
        /*XXXXXXXXXX
        
        
        if (folder != null) {
        profile.getFolders().add(folder);
        tblPlugins.updateUI();
        }*/
    }//GEN-LAST:event_btnAddActionPerformed

    private void btnDeleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDeleteActionPerformed
        JOptionPane.showMessageDialog(this, resourceBundle.getString("pp_not_supported"));
        /*if (tblPlugins.getSelectionModel().isSelectionEmpty()) {
        return;
        }
        
        XXXXXXXXXXXXX
        
        tblPlugins.updateUI();*/
    }//GEN-LAST:event_btnDeleteActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnAdd;
    private javax.swing.JButton btnDelete;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable tblPlugins;
    // End of variables declaration//GEN-END:variables

    // http://stackoverflow.com/questions/3167112/remove-cells-border-in-a-jtable	
    private class FolderTableRenderer extends DefaultTableCellRenderer {

        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
            this.setBorder(BorderFactory.createEmptyBorder());

            return this;
        }
    }

    public class FolderTableHeaderRenderer extends JLabel implements TableCellRenderer {
        // This method is called each time a column header
        // using this renderer needs to be rendered.

        public Component getTableCellRendererComponent(JTable table, Object value,
                boolean isSelected, boolean hasFocus, int rowIndex, int vColIndex) {
            // 'value' is column header value of column 'vColIndex'
            // rowIndex is always -1
            // isSelected is always false
            // hasFocus is always false

            // Configure the component with the specified value
            setText(value.toString());

            // Set tool tip if desired
            //setToolTipText((String)value);

            // Since the renderer is a component, return itself
            return this;
        }

        // The following methods override the defaults for performance reasons
        public void validate() {
        }

        public void revalidate() {
        }

        protected void firePropertyChange(String propertyName, Object oldValue, Object newValue) {
        }

        public void firePropertyChange(String propertyName, boolean oldValue, boolean newValue) {
        }
    }

    public class FolderTableCellRenderer extends DefaultTableCellRenderer {

        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, final int row, int column) {

            JLabel cellSpacingLabel = new JLabel();

            if (hasFocus) {
                setBorder(UIManager.getBorder("Table.focusCellHighlightBorder"));
                cellSpacingLabel = null;
            } else {
                setBackground(table.getBackground());
                setBorder(null);
            }

            if (isSelected) {
                setBackground(table.getSelectionBackground());
                setBorder(null);
            } else {
                setBackground(table.getBackground());
                setBorder(null);
            }

            if (cellSpacingLabel != null) {
                cellSpacingLabel.setBorder(new CompoundBorder(new EmptyBorder(new Insets(1, 4, 1, 4)), cellSpacingLabel.getBorder()));
            }

            setOpaque(true);
            setText((String) value);

            return this;
        }
    }

    private class PluginsTableModel implements TableModel {

        public static final int COLUMN_COUNT = 3;
        public static final int COLUMN_INDEX_ACTIVE = 0;
        public static final int COLUMN_INDEX_NAME = 1;
        public static final int COLUMN_INDEX_VERSION = 2;
        private List<TableModelListener> listeners;

        public PluginsTableModel() {
            listeners = new LinkedList<TableModelListener>();
        }

        @Override
        public int getRowCount() {
            return Plugins.list().size();
        }

        @Override
        public int getColumnCount() {
            return COLUMN_COUNT;
        }

        @Override
        public String getColumnName(int columnIndex) {
            switch (columnIndex) {
                case COLUMN_INDEX_ACTIVE:
                    return resourceBundle.getString("pp_active_index");
                case COLUMN_INDEX_NAME:
                    return resourceBundle.getString("pp_plugin_index");
                case COLUMN_INDEX_VERSION:
                    return resourceBundle.getString("pp_version_index");
            }

            return null;
        }
		
        /*
         * JTable uses this method to determine the default renderer/
         * editor for each cell.  If we didn't implement this method,
         * then the last column would contain text ("true"/"false"),
         * rather than a check box.
         *
         * @see http://download.oracle.com/javase/tutorial/uiswing/examples/components/TableRenderDemoProject/src/components/TableRenderDemo.java
         */
        @Override
        public Class<?> getColumnClass(int columnIndex) {
            return getValueAt(0, columnIndex).getClass();
        }

        @Override
        public boolean isCellEditable(int rowIndex, int columnIndex) {
            return false;
        }

        @Override
        public Object getValueAt(int rowIndex, int columnIndex) {
            if (rowIndex > getRowCount() - 1) {
                throw new ArrayIndexOutOfBoundsException("Table only has " + getRowCount() + " rows. Index " + rowIndex + " is out of bounds.");
            }

            PluginInfo plugin = new ArrayList<PluginInfo>(Plugins.list()).get(rowIndex);

            switch (columnIndex) {
                case COLUMN_INDEX_ACTIVE:
                    return true;
                case COLUMN_INDEX_NAME:
                    return plugin.getName();
                case COLUMN_INDEX_VERSION:
                    return plugin.getVersionStr();
            }

            throw new ArrayIndexOutOfBoundsException("Table only has " + getColumnCount() + " columns. Index " + columnIndex + " is out of bounds.");
        }

        @Override
        public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
            if (rowIndex > getRowCount() - 1) {
                throw new ArrayIndexOutOfBoundsException("Table only has " + getRowCount() + " rows. Index " + rowIndex + " is out of bounds.");
            }

            logger.warning("setValue(" + aValue + ", " + rowIndex + ", " + columnIndex + "): Not supported");
            return;
        }

        @Override
        public synchronized void addTableModelListener(TableModelListener l) {
            listeners.add(l);
        }

        @Override
        public synchronized void removeTableModelListener(TableModelListener l) {
            listeners.remove(l);
        }
    }
}
